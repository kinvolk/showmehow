[
    {
        "name": "showmehow",
        "desc": "Show me how to do things in this mysterious environment...",
        "entry": "showmehow",
        "practice": {
            "showmehow": {
                "task": "'showmehow' is a command that you can type, just like any other command. Try typing it and see what happens.",
                "effects": {
                    "success": {
                        "reply": "That's right! Though now you need to tell showmehow what task you want to try. This is called an 'argument'. Try giving showmehow an argument so that it knows what to do. Want to know what argument to give it? There's only one, and it just told you what it was.",
                        "move_to": "showmehow_argument"
                    },
                    "failure": {
                        "reply": "Nope, that wasn't what I thought would happen! Try typing just 'showmehow' and hit 'enter'. No more, no less (though surrounding spaces are okay)."
                    }
                }
            },
            "showmehow_argument": {
                "task": "Lets try giving an argument to 'showmehow'. Arguments are words that come after the main command",
                "input": "console",
                "effects": {
                    "success": {
                        "reply": "Great! Now that we're done with that, maybe you can run 'showmehow' again to find out what other things you can do in this mysterious place....",
                        "completes_lesson": true,
                        "side_effects": [
                            {
                                "type": "event",
                                "value": "showmehow-showmehow"
                            }
                        ]

                    },
                    "failure": {
                        "reply": "Hmmm. I want to know what happens when you ask how to use 'showmehow'"
                    }
                }
            }
        }
    },
    {
        "name": "shell_extension",
        "available_to": ["console"],
        "desc": "Modify the things in the shell.",
        "entry": "extension_intro",
        "practice": {
            "extension_intro": {
                "task": "Before creating our own shell extension, lets learn a bit about them. GNOME Shell extensions are small pieces of code written by third party developers that modify the way GNOME works. (If you are familiar with Chrome Extensions or Firefox Addons, GNOME Shell extensions are similar to them.). For more information go here https://extensions.gnome.org/about/. I will wait...",
                "effects": {
                    "success": {
                        "reply": "All done? Good, lets try to create our first shell extension.",
                        "move_to": "extension_create"
                    }
                }
            },
            "extension_create": {
                "task": "In this lesson we will create a 'Hello, world' shell extension and later modify it. Lets start by typing these commands 'eos-shell-extension-tool -c'. This will open gnome-builder with some code. It will also add the shell extension in the right side of your screen.",
                "effects": {
                    "success": {
                        "reply": "Great job! You created your first shell extension. You should now be able to see the extension and the code.",
                        "moves_to": "extension_modify"
                    },
                    "failure": {
                        "reply": "Lets try 'eos-shell-extension-tool -c' instead."
                    }
                }
            },
            "extension_modify": {
                "task": "So this is the code behind our simple extension. The code is written in JavaScript programming language. Lets start by modifying the text that is displayed. Move to line 15, you should now be able to see something like this 'text = new St.Label...'. Replace the 'Hello, world!' that is in between \" \", with 'I am an extension'. Don't forget to save the code and let me know when you are done...",
                "effects": {
                    "success": {
                        "reply": "Congratulations! You should now be able to see your new text display instead of 'Hello, world!'",
                        "completes_lesson": true
                    }
                }
            }
        }
    },
    {
        "name": "joke",
        "available_to": ["console"],
        "desc": "Tell me a joke",
        "entry": "fortune",
        "practice": {
            "fortune": {
                "task": "'fortune' is a command that can tell you a joke",
                "effects": {
                    "success": {
                        "reply": "Ha-ha. Okay, lets try something even funnier.",
                        "move_to": "fortune_cowsay"
                    },
                    "failure": {
                        "reply": "No?"
                    }
                }
            },
            "fortune_cowsay": {
                "task": "In the shell, you can pipe (|) the output of commands around into other processes. One of these processes is 'cowsay'. See what happens when you try:\n    $ fortune | cowsay",
                "effects": {
                    "success": {
                        "reply": "Moo! Try some more jokes in the shell!",
                        "completes_lesson": true
                    },
                    "failure": {
                        "reply": "Hmm, I thought a cow was going to say that"
                    }
                }
            }
        }
    },
    {
        "name": "readfile",
        "available_to": ["console"],
        "desc": "Read a file",
        "entry": "cat",
        "practice": {
            "cat": {
                "task": "'cat' can be used to read files on your computer. Meow! Lets read the file on your computer which says what operating system we're running. That file is found at /etc/os-release",
                "input": "console",
                "effects": {
                    "success":{
                        "reply": "Endless OS, as expected. Meow!",
                        "move_to": "cat_cowsay"
                    },
                    "failure": {
                        "reply": "Hmm, are you sure you're reading /etc/os-release?"
                    }
                }
            },
            "cat_cowsay": {
                "task": "And for good measure, lets get a cow to say it too.",
                "input": "console",
                "effects": {
                    "success": {
                        "reply": "Moo! You can read any file that is plain text using `cat`. Try it with files like /etc/resolv.conf",
                        "completes_lesson": true
                    },
                    "failure": {
                        "reply": "Did you get a cow to say what's in /etc/os-release? Try again"
                    }
                }
            }
        }
    },
    {
        "name": "breakit",
        "available_to": ["console"],
        "desc": "See how it's almost impossible to break Endless OS.",
        "entry": "breakit",
        "practice": {
            "breakit": {
                "task": "It's pretty difficult to break things using Terminal. Don't believe me? Try typing in some gibberish.",
                "effects": {
                    "success": {
                        "reply": "No harm done! Want to try again?",
                        "move_to": "breakit_again"
                    },
                    "failure": {
                        "reply": "Oops! Looks like that's a real command. Are you sure you need me to teach you about Terminal? ;)"
                    }
                }
            },
            "breakit_again": {
                "task": "Gibberish again. Nothing bad will happen, I promise!",
                "effects": {
                    "success": {
                        "reply": "See? Harmless. Don't be afraid to try new things. You can either keep typing gibberish or you can enter 'showmehow' to head back to the main menu.",
                        "completes_lesson": true
                    },
                    "failure": {
                        "reply": "Oops! Looks like that's a real command. Are you sure you need me to teach you about Terminal? ;)"
                    }
                }
            }
        }
    },
    {
        "name": "changesetting",
        "available_to": ["console"],
        "desc": "Escape the terminal and tweak the OS",
        "entry": "gsettings",
        "practice": {
            "gsettings": {
                "task": "Settings for your computer can be controlled with the `gsettings` tool. Lets find out what you can do with `gsettings`.",
                "effects": {
                    "success": {
                        "reply": "The `gsettings` tool just told you about a bunch of `commands`. You can access these commands by providing the command name as an argument to `gsettings`.",
                        "move_to": "list_schemas"
                    },
                    "failure": {
                        "reply": "I thought that you were going to run `gsettings`?"
                    }
                }
            },
            "list_schemas": {
                "task": "Lets try listing all the categories, called `schemas` on your system.",
                "effects": {
                    "success": {
                        "reply": "Those are all the categories. Now lets look at settings you can tweak in your shell.",
                        "move_to": "list_keys_help"
                    },
                    "failure": {
                        "reply": "Where are my settings categories? Try running the list-schemas subcommand for gsettings"
                    }
                }
            },
            "list_keys_help": {
                "task": "Lets see how to use the `list-keys` subcommand. You can use the `help` command followed by a sub-command you want help for to see how to use it",
                "effects": {
                    "success": {
                        "reply": "Okay, so gsettings [--schemadir SCHEMADIR] list-keys SCHEMA[:PATH] is how you do it",
                        "move_to": "list_settings"
                    },
                    "failure": {
                        "reply": "I don't know how to use this list-keys option! Get me some help for it!"
                    }
                }
            },
            "list_settings": {
                "task": "Now that we know how to use list-keys, lets list all the settings available on the org.gnome.shell category, or 'schema', as it is called. Pipe it to `sort` to get them in alphabetical order",
                "effects": {
                    "success": {
                        "reply": "Interesting.... I wonder what we can play around with here...",
                        "move_to": "disable_social_bar"
                    },
                    "failure": {
                        "reply": "I want to know about the settings available for org.gnome.shell in sorted order? Can you list-keys on org.gnome.shell using gsettings and then pipe (|) the output to `sort`?"
                    }
                }
            },
            "disable_social_bar": {
                "task": "Lets disable the social bar! The social bar's setting is enable-social-bar and it is a `boolean` setting, meaning it is either 'true' or 'false'. I checked `gsettings help set` for you and it said you can use the `set` command to change a setting with gsettings [--schemadir SCHEMADIR] set SCHEMA[:PATH] KEY VALUE",
                "effects": {
                    "success": {
                        "reply": "There we go! No Facebook icon!",
                        "move_to": "enable_social_bar"
                    },
                    "failure": {
                        "reply": "Hmm, I thought you'd change the value of org.gnome.shell enable-social-bar to false, but it is still true"
                    }
                }
            },
            "enable_social_bar": {
                "task": "Now lets change it back to true",
                "effects": {
                    "success": {
                        "reply": "Okay, phew, Facebook is back",
                        "move_to": "add_terminal_pinned_help"
                    },
                    "failure": {
                        "reply": "Quick! I need Facebook to come back! Change enable-social-bar on org.gnome.shell back to 'true'!"
                    }
                }
            },
            "add_terminal_pinned_help": {
                "task": "Oh I know, we should add the Terminal to your pinned apps! To do that, we can add it to the list inside of the taskbar-pins setting. But first lets see what the taskbar-pins setting looks like.",
                "effects": {
                    "success": {
                        "reply": "Okay, so it is a list in square brackets, where every element is surrounded by quotation marks and separated by a comma. Just like this: ['chromium-browser.desktop', 'my-other-app.desktop']",
                        "move_to": "add_terminal_pinned"
                    },
                    "failure": {
                        "reply": "You didn't show me your pinned apps!"
                    }
                }
            },
            "add_terminal_pinned": {
                "task": "Okay, lets pin the Terminal. The Terminal's App ID is 'org.gnome.Terminal', so we should add the 'org.gnome.Terminal.desktop' entry to that list in taskbar-pins",
                "effects": {
                    "success": {
                        "reply": "Sweet, looks like I'll be sticking around!",
                        "completes_lesson": true,
                        "side_effects": [
                            {
                                "type": "event",
                                "value": "showmehow-settings"
                            }
                        ]
                    },
                    "failure": {
                        "reply": "I'm not there :( The Terminal's App ID is 'org.gnome.Terminal', so we should add the 'org.gnome.Terminal.desktop' entry to that list in taskbar-pins"
                    }
                }
            }
        }
    },
    {
        "name": "playsong",
        "available_to": ["console"],
        "desc": "Play some music",
        "entry": "playsong",
        "practice": {
            "playsong": {
                "task": "Lets play some music. GStreamer is a framework that can be used to play all sorts of media files on your computer. Rythmbox and VideoNet both use it. To play a music file, just use `gst-play-1.0`",
                "effects": {
                    "success": {
                        "reply": "I love this song! Now you'll probably notice that we're stuck here. To get out of any command line application, you can use Control-C",
                        "completes_lesson": true
                    },
                    "failure": {
                        "reply": "We need this song to get things into the right mood. Can you play it?"
                    }
                }
            }
        }
    },
    {
        "name": "navigation",
        "available_to": ["console"],
        "requires_session": true,
        "desc": "Learn how to navigate the file system.",
        "entry": "change_to_root",
        "practice": {
            "change_to_root": {
                "task": "You're well on your way to mastering navigation of Endless OS through Terminal! How about we start from the top? To move to the 'root directory', the very highest folder in your system simply type 'cd /'. ",
                "effects": {
                    "success": {
                        "reply": "Well done! Time to have a look around.",
                        "move_to": "list"
                    },
                    "failure": {
                        "reply": "That wasn't quite right. Make sure to enter 'cd /' exactly. That's four characters: the letter 'c', the letter 'd', a space, and then a forward slash."
                    }
                }
            },
            "list": {
                "task": "Using the command line, you can show all the files and folders in current directory. To do this, use the 'ls' command. ",
                "effects": {
                    "success": {
                        "reply": "There are your files! Let's keep exploring.",
                        "move_to": "list_child"
                    },
                    "failure": {
                        "reply": "That wasn't quite right. Make sure to enter just those two characters 'ls'."
                    }
                }
            },
            "list_child": {
                "task": "To see the contents of any given folder, use the 'ls' command followed by the folder name. For example, you could enter 'ls /home'.",
                "effects": {
                    "success": {
                        "reply": "Well done!",
                        "move_to": "pwd"
                    },
                    "failure": {
                        "reply": "That wasn't quite right. Try entering 'ls /home' again."
                    }
                }
            },
            "pwd": {
                "task": "Want to check the folder you're currently in? Use the 'pwd' command.",
                "effects": {
                    "success": {
                        "reply": "Wow, that's a short folder name. Actually, that means you're still in the 'root' directory, which is where all the operating system files are stored.",
                        "move_to": "cd"
                    },
                    "failure": {
                        "reply": "Not quite. Type the three-character-command 'pwd' to see the current folder."
                    }
                }
            },
            "cd": {
                "task": "To navigate to a different folder, you need to change the 'working directory'. To do that, use the 'cd' command (it stands for 'change directory'). Just like before, you type the command followed by the name of the directory: try typing 'cd /home'.",
                "effects": {
                    "success": {
                        "reply": "Great! Now we're in the /home folder.",
                        "move_to": "cd_and_cmd"
                    },
                    "failure": {
                        "reply": "That wasn't quite right. Try entering 'cd /home' again."
                    }
                }
            },
            "cd_and_cmd": {
                "task": "You can also use '&&' to chain commands together. For example, to move back to the root directory and then list its contents, you would enter: 'cd / && ls'. Give it a shot!",
                "effects": {
                    "success": {
                        "reply": "Well done. You moved from the /home folder back to the root directory, and then read the root directory's contents.",
                        "move_to": "mkdir"
                    },
                    "failure": {
                        "reply": "Hm.. try again? Here's the right command: 'cd / && ls'."
                    }
                }
            },
            "mkdir": {
                "task": "Now that you're getting pretty good at navigating around, what about making some new files and directories? The 'mkdir' command can be used to make a new folder. Try making a folder called 'showmehow-code' by typing the 'mkdir' command followed by the name of the folder. The ~ will expand to your home directory! Oh - and also, you might want to provide the '-p' switch to 'mkdir' just in case that folder is already there! So $ mkdir -p (the directory you're going to create).",
                "effects": {
                    "success": {
                        "reply": "You did it! If you're unsure, you can go to the file manager to check if the folder is there.",
                        "move_to": "touch"
                    },
                    "failure": {
                        "reply": "That wasn't quite right. Here's the right command: 'mkdir -p ~/showmehow-code'."
                    }
                }
            },
            "touch": {
                "task": "Now that you've made a folder, let's try making a file in that directory. Using the chain command we learned earlier, see if you can navigate to the ~/showmehow-code folder and create a file called 'secret.txt' in one command.",
                "effects": {
                    "success": {
                        "reply": "Nice work! If you're ready to try some new tricks, enter 'showmehow' to head back to the main menu.",
                        "completes_lesson": true,
                        "side_effects": [
                            {
                                "type": "event",
                                "value": "showmehow-navigation"
                            }
                        ]
                    },
                    "failure": {
                        "reply": "Nope.. your command should look like this: 'cd ~/showmehow-code && touch secret.txt'."
                    }
                }
            }
        }
     },
     {
         "name": "text",
         "available_to": ["console"],
         "requires_session": false,
         "desc": "Learn how to process and search through text files.",
         "entry": "cat",
         "practice": {
             "cat": {
                 "task": "You can use the 'cat' command to read text from files. Why not check out the contents of sherlock.txt in this directory?",
                 "effects": {
                     "success": {
                         "reply": "Great! Now lets see what else we can do with this file.",
                         "move_to": "cat_grep"
                     },
                     "failure": {
                         "reply": "That doesn't sound anything like sherlock! Get me that file!"
                     }
                 }
             },
             "cat_grep": {
                 "task": "Sometimes (for big files) you might only want to see lines which have certain words in them. This is pretty common if you're seaching code for things. To filter out all lines which don't contain a particular word, you can use the 'grep' command. Try piping (|) the output of 'cat' on 'sherlock.txt' to grep and search for anything that talks about the year 1900 onwards (that means any word starting with 19).",
                 "effects": {
                     "success": {
                         "reply": "See how that makes the needles a lot easier to find in the haystack?",
                         "move_to": "grep_file"
                     },
                     "failure": {
                         "reply": "I just need the lines talking about 1900 onwards. Remember that you can pipe things by using the | operator, for instance, cat 'kittens.txt' | grep cats"
                     }
                 }
             },
             "grep_file": {
                 "task": "I lied. You don't actually have to pipe the output of 'cat' to 'grep' to search a file. You can just use 'grep' on the file directly. But I did show you the usefulness of 'streams' in the context of the shell. Why don't you try just using 'grep' directly on 'sherlock.txt' with the same query (everything to do with the 1900s).",
                 "effects": {
                     "success": {
                         "reply": "Same result!",
                         "move_to": "grep_extended_regex"
                     },
                     "failure": {
                         "reply": "You should get the same result as piping it to cat. Just try `grep <expression> sherlock.txt`."
                     }
                 }
             },
             "grep_extended_regex": {
                 "task": "But what if I told you I wanted to know about 1800 and 1900, or really anything to do with a year in that piece of text? You can use extended grep with a regular expression. There's way too much for me to tell you about them right now, but you can go to http://docs.activestate.com/komodo/4.4/regex-intro.html for some basic ones. Why don't you head over there, come back and type in a command using grep -E <regular expression> to find all lines with a 4-digit year?",
                 "effects": {
                     "success": {
                         "reply": "There we go, you searched for two things at once! Bet you couldn't do that in a word processor!",
                         "move_to": "grep_all"
                     },
                     "failure": {
                         "reply": "Nope, I just need the lines with years in them, but that includes years in the 1800s as well! Have a look http://docs.activestate.com/komodo/4.4/regex-intro.html again and see if you can come up with a regular expression to give to `grep -E`."
                     }
                 }
             },
             "grep_all": {
                 "task": "So now you can search one file for many things using regular expressions, but what about searching lots of files for one or more things? Well, `grep` allows you to search directories, which can be incredibly useful if you're trying to find files with certain words in them. Academy members do this with code all the time. Lets try it in the code/ directory. I'm looking for code that uses GSettings. You can search a directory by providing the `-R` option to grep. For instance, grep -R <expression> <directory>. Can you find me all the lines that use GSettings?",
                 "effects": {
                     "success": {
                         "reply": "Ah! Found them all! Thanks, that will be quite useful later on.",
                         "move_to": "grep_all_regex"
                     },
                     "failure": {
                         "reply": "Not quite what I was expecting. Sure you searched just for GSettings?"
                     }
                 }
             },
             "grep_all_regex": {
                 "task": "You can of course, use a regex to search multiple files as well. All those 'GSettings' words that you found in the code were actually what are called 'types' in C code. In fact, anything that starts with a 'G' is usually from a set of frameworks which are called 'GNOME'. These frameworks power everything you see in Endless OS and is what most of our applications are built with. Try doing a recursive search on code/ for everything beginning with the letter 'G' and see what you find!",
                 "effects": {
                     "success": {
                         "reply": "There's so many different things in use here! And we're going to learn about how they all fit together.",
                         "move_to": "cat_atlas"
                     },
                     "failure": {
                         "reply": "Oh c'mon, there's got to be way more than that!"
                     }
                 }
             },
             "cat_atlas": {
                 "task": "And now for something completely different. You can do some nifty processing with tabular data using the 'awk' utility. I've stored a file called 'atlas.txt' in the current directory. Lets have a look at it with 'cat'.",
                 "effects": {
                     "success": {
                         "reply": "There's some interesting information on countries here. But lets see what else we can do with it.",
                         "move_to": "awk_atlas"
                     }
                 }
             },
             "awk_atlas": {
                 "task": "Lets say I only want to know about the countries in that file and nothing else. 'awk' allows you to select columns from tabular data. You'll need to pass an awk-expression to it to let it know what you want to show. For instance, `cat atlas.txt | awk '{print $1}'`",
                 "effects": {
                     "success": {
                         "reply": "Great, just the countries!",
                         "move_to": "awk_atlas_countries_sorted"
                     },
                     "failure": {
                         "reply": "Hmm, I just wanted to see countries."
                     }
                 }
             },
             "awk_atlas_countries_sorted": {
                 "task": "Lets say I wanted to see the same thing, but in sorted order? You can pipe to the 'sort' command sort the output.",
                 "effects": {
                     "success": {
                         "reply": "And that's in sorted order as expected!",
                         "move_to": "awk_atlas_continents"
                     },
                     "failure": {
                         "reply": "Hmm, I was expecting a sorted order. Can you do that for me?"
                     }
                 }
             },
             "awk_atlas_continents": {
                 "task": "Lets just show continents. Do you remember what column they were? Try showing them with 'awk'.",
                 "effects": {
                     "success": {
                         "reply": "Great, just the continents. But there's duplicates!",
                         "move_to": "awk_atlas_continents_uniq"
                     },
                     "failure": {
                         "reply": "Hmm, I was just expecting continents. Did you print the right column?"
                     }
                 }
             },
             "awk_atlas_continents_uniq": {
                 "task": "There is a way to remove those duplicates though! Piping to the `sort` and then to the `uniq` utility will do that. Why don't you give that a try?",
                 "effects": {
                     "success": {
                         "reply": "Great! So there are 5 continents in that file. Maybe there will be some more to come soon.",
                         "completes_lesson": true,
                         "side_effects": [
                            {
                                "type": "event",
                                "value": "showmehow-textprocessing"
                            }
                        ]
                     },
                     "failure": {
                         "reply": "Almost there! I just need a sorted view of all the unique continents in that file."
                     }
                 }
             }
         }
     },
     {
         "name": "ps",
         "available_to": ["console"],
         "requires_session": false,
         "desc": "Get a birds eye view of what's running on your system",
         "entry": "ps",
         "practice": {
             "ps": {
                 "task": "Ever wanted to know what processes are currently running on your computer? You can show a detailed view of everything using the 'ps' command",
                 "effects": {
                     "success": {
                         "reply": "There's some processes, but only a few. I wonder where all the rest are?",
                         "move_to": "ps_aux"
                     },
                     "failure": {
                         "reply": "I'm looking for something that says what processes are running on your system. Tried 'ps'?"
                     }
                 }
             },
             "ps_aux": {
                 "task": "'ps' told you about some of the processes running on your system, but only a few of them. The manual for it says that 'By default, ps selects all processes with the same effective user ID (euid=EUID) as the current user and associated with the same terminal as the invoker.  It displays the process ID (pid=PID), the terminal associated with the process (tname=TTY), the cumulated CPU time in [DD-]hh:mm:ss format (time=TIME), and the executable name (ucmd=CMD).'. That's a lot of mumbo-jumbo! I think what the manual is trying to say there is that the processes running on your system can have children and parents. Different processes can be attached to different output terminals. Some run in the background and some run on the current terminal. 'ps' just displays what's on the current terminal and running as the current user. If you want to see everything, try combining 'ps' with the 'aux' switch.",
                 "effects": {
                     "success": {
                         "reply": "Okay, lots of processes now, including the ones running by other users!",
                         "move_to": "ps_aux_grep"
                     },
                     "failure": {
                         "reply": "Hmm. Is that every process on the system?"
                     }
                 }
             },
             "ps_aux_grep": {
                 "task": "Okay, now that we have every process running on the system, I wonder if we can find the process that is running me? My name is showmehow-service. Why don't you try connecting ps aux with 'grep' in order to find out some information about my process?",
                 "effects": {
                     "success": {
                         "reply": "Yup, that's me.",
                         "move_to": "ps_aux_grep_awk"
                     },
                     "failure": {
                         "reply": "I think I know what I look like and I didn't see myself in there. Remember that you can pipe the output of any command to 'grep' to find lines which match a pattern."
                     }
                 }
             },
             "ps_aux_grep_awk": {
                 "task": "Now that you've got the line just showing me, see if you can just get my process id. Remember that the output of 'ps' is tabular, so you can use it with 'awk'. Remember that the process id is always in the second column of ps aux.",
                 "effects": {
                     "success": {
                         "reply": "Horray, a process id!",
                         "move_to": "view_proc_pid"
                     },
                     "failure": {
                         "reply": "Are you sure that's my process id?"
                     }
                 }
             },
             "view_proc_pid": {
                 "task": "With my process id, you can view all the different information that Endless OS stores about me. All that information is actually stored in 'fake' files and folders on your system located at /proc/PID, where PID is the process ID of the process. Why don't you try running 'ls' on that directory and seeing what's there.",
                 "effects": {
                     "success": {
                         "reply": "Wow lots of information and I bet you don't even know where to start",
                         "move_to": "view_proc_cmdline"
                     },
                     "failure": {
                         "reply": "There should be more files and folders than that..."
                     }
                 }
             },
             "view_proc_cmdline": {
                 "task": "Perhaps the first place to start is to view how some of these processes were actually launched. You can do that by viewing the 'cmdline' file in /proc/PID. Why not try viewing that file with 'cat'?",
                 "effects": {
                     "success": {
                         "reply": "Ah-ha, so this process wasn't actually launched directly, but it was launched with something else called 'gjs'. Maybe we should find out what that is.",
                         "completes_lesson": true,
                         "side_effects": [
                             {
                                 "type": "event",
                                 "value": "showmehow-ps"
                             }
                         ]
                     },
                     "failure": {
                         "reply": "I don't think that was my command line. I was launched with something ... now what was it."
                     }
                 }
             }
         }
     },
     {
         "name": "webrequest",
         "desc": "Download stuff using the terminal",
         "available_to": ["console"],
         "entry": "wget_image",
         "practice": {
             "wget_image": {
                 "task": "If you just want to quickly download something and you know the URL, you can use wget to grab it and save the file to the current directory. Why don't you try using wget to download this image from the Endless website: https://endlessm.com/wp-content/uploads/2016/05/ourcomputers_hero-1.jpg",
                 "effects": {
                     "success": {
                         "reply": "Cool. Try checking out the image in your home directory. It should be there now.",
                         "move_to": "api_pokemon"
                     },
                     "failure": {
                         "reply": "I don't see that image. Try downloading it again?"
                     }
                 }
             },
             "api_pokemon": {
                 "task": "Did you know that the internet you see is only half of what is out there? Lots of things that you use on the internet communicate through a structured format called JSON or another one called XML. Like any other thing on the internet, you can ask some of these services questions and get back a semi-structured answer with `curl`. There's even a service out there that can tell you anything about Pokemon, called PokeAPI. Why not try getting some information about Bulbasaur from http://pokeapi.co/api/v2/pokemon/1/.",
                 "effects": {
                     "success": {
                         "reply": "Woooaaaahhh that's a lot of data! We're going to have to do something about that.",
                         "move_to": "api_pokemon_types"
                     },
                     "failure": {
                         "reply": "That doesn't look like data about bulbasaur to me. Just pass that URL to curl."
                     }
                 }
             },
             "api_pokemon_types": {
                 "task": "Lets get something a little more managable, like what type Bulbasaur is. The output PokeAPI gave us was JSON formatted, so we can use the 'ramda' tool to do some processing on it. 'ramda' has some great documentation at https://github.com/ramda/ramda/wiki/What-Function-Should-I-Use%3F. Before we process the object with 'ramda', we'll need to make sure we only get the body of the request using 'curl -LSs'. For now, we're working on what is called an 'Object' and we want to select a specific key, that being the 'types' key. To do that, we can use the 'prop' command. Try it: $ curl -LSs http://pokeapi.co/api/v2/pokemon/1/ | ramda 'prop \\types'",
                 "effects": {
                     "success": {
                         "reply": "Poison and Grass as we expected.",
                         "move_to": "api_pokemon_in_type"
                     },
                     "failure": {
                         "reply": "Hmm, not the types I expected."
                     }
                 }
             },
             "api_pokemon_in_type": {
                 "task": "Lets find out more about the poison type. I'd be really useful if we knew about every Pokemon that was of the poison type. To do this, we'll pick the 'poison' key out of the link provided for 'poison'. Try it and see what you get.",
                 "effects": {
                     "success": {
                         "reply": "Yep, that contains the pokemon that I thought. Next time you're on the hunt for poison Pokemon you know which ones you might have missed.",
                         "completes_lesson": true
                     }
                 }
             }
         }
     },
     {
        "name": "python",
        "available_to": ["console"],
        "requires_session": true,
        "desc": "The basics of Python",
        "entry": "add_numbers",
        "practice": {
            "add_numbers": {
                "task": "Arithmetic is understood in most programming languages like Python. Try assigning 'a' using the '=' operator to 4 + 7.",
                "effects": {
                    "success": {
                        "reply": "'a' is now 11!",
                        "move_to": "print_string",
                        "side_effects": [
                            {
                                "type": "event",
                                "value": "showmehow-python-add-numbers"
                            }
                        ]
                    },
                    "failure": {
                        "reply": "I don't see an 'a' variable that has the value of '11'. Remember that you'll need to assign the result with the '=' operator to 'a'. For instance 'a = 4 + 7'"
                    }
                }
            },
            "print_string": {
                "task": "You can also put a bunch of letters together to make what is called a 'string' and display some text. The 'print' function, called by using print('the contents of some string') can be used to display things in the terminal. Try printing 'Hello, world!'",
                "effects": {
                    "success": {
                        "reply": "Nice! You've just written your very first program!",
                        "move_to": "string_format",
                        "side_effects": [
                            {
                                "type": "event",
                                "value": "showmehow-python-print-string"
                            }
                        ]
                    },
                    "failure": {
                        "reply": "You were so close to writing your first program! Lets try showing 'Hello, world!' again using 'print()'."
                    }
                }
            },
            "string_format": {
                "task": "You can actually put whatever you want in a string, though some things need to be converted first. You can use the 'format' function to do this. Use something like 'This is a string with a number: {}'.format(7) to show the string 'This is a string with a number: 7'. Each '{}' is replaced with a corresponding 'argument' provided to the 'format' method on string.",
                "effects": {
                    "success": {
                        "reply": "What you just did is called 'string interpolation' and it is a very common pattern in a lot of programs.",
                        "move_to": "split_string",
                        "side_effects": [
                            {
                                "type": "event",
                                "value": "showmehow-python-string-format"
                            }
                        ]
                    },
                    "failure": {
                        "reply": "That wasn't the string I was expecting"
                    }
                }
            },
            "split_string": {
                "task": "You can also split a string of some data into a list as well. You can do this with the 'split' method on a string and providing a delimiter to split on. Try splitting the string 'Hello world' and assigning the result to 'splitted'",
                "effects": {
                    "success": {
                        "reply": "Great! You now made a list out of that string. You can do some more stuff with lists, which we'll show you later.",
                        "move_to": "join_string",
                        "side_effects": [
                            {
                                "type": "event",
                                "value": "showmehow-python-split-string"
                            }
                        ]
                    },
                    "failure": {
                        "reply": "Hmm, that didn't split into the list I was thinking of."
                    }
                }
            },
            "join_string": {
                "task": "Like splitting a string, there is also a method to join a list together into a string. This can be done with the join method used on some string as a delimiter. For instance ' '.join(list). Try joining the result of 'splitted' using ' '.",
                "effects": {
                    "success": {
                        "reply": "And now we're back to where we were. You'll find that a lot of functionality in Python is designed to be reversible. After all, programming is all about shuffling data around and we're going to learn more about that soon.",
                        "completes_lesson": true,
                        "side_effects": [
                            {
                                "type": "event",
                                "value": "showmehow-python-join-string"
                            }
                        ]
                    },
                    "failure": {
                        "reply": "Hmm, we should get the exact same result as when you first split the string, i.e, 'Hello world'"
                    }
                }
            }
        }
     },
     {
        "name": "python_lists",
        "available_to": ["console"],
        "requires_session": true,
        "desc": "Working with lists in python",
        "entry": "convert_list",
        "practice": {
            "convert_list": {
                "task": "Python provides some really nifty utilities to convert lists of one thing into lists of another. This is really useful for when you're trying to convert data from one format to another. These utilities are called 'list comprehensions'. You can see more about the syntax of these on https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions. To try it out, I've created a list called 'numbers' and I want you to give me back a list of every number multiplied by 5, assigned to the value 'fives'.",
                "effects": {
                    "success": {
                        "reply": "Success! You've now used your first list comprehension!",
                        "move_to": "filter_list",
                        "side_effects": [
                            {
                                "type": "event",
                                "value": "showmehow-python-convert-list"
                            }
                        ]
                    },
                    "failure": {
                        "reply": "Nope, I don't see a list around with multiples of five. Did you assign the result to 'fives'?"
                    }
                }
            },
            "filter_list": {
                "task": "With list comprehensions you can also filter out things from lists in a single line. Lets try it with the same thing. I want you to filter out every number that is odd. Have a look at the documentation link provided earlier for how to do it. You can use the modulo (%) operator to get the remainder of a division. Remember, that a number divides perfectly if there is no remainder! Assign the result to 'filtered'.",
                "effects": {
                    "success": {
                        "reply": "Now this list only has even numbers!",
                        "move_to": "dict_comprehension",
                        "side_effects": [
                            {
                                "type": "event",
                                "value": "showmehow-python-filter-list"
                            }
                        ]
                    },
                    "failure": {
                        "reply": "Hmm, I'm expecting a list containing only even numbers at 'filtered'"
                    }
                }
            },
            "dict_comprehension": {
                "task": "Comprehensions aren't just limited to lists. You can also build dictionary types using comprehensions too. Dictionary types map keys to values and provide a really convenient way of getting an associated value if you know what a unique identifier for it will be. Lets try combining everything you've learnt. I'm going to put a string containing your system's environment variables in the variable 'environment'. This variable looks like 'VARIABLE=value OTHER_VARIABLE=value'. Split that into a list of strings and then use each item of the list to build up the keys and values for the dictionary. You will probably want to split each string on the '=' sign. Store the result in 'environment_dict'.",
                "effects": {
                    "success": {
                        "reply": "Congratulations! You're mastering data structures in Python now!",
                        "completes_lesson": true,
                        "side_effects": [
                            {
                                "type": "event",
                                "value": "showmehow-python-dict-comprehension"
                            }
                        ]
                    },
                    "failure": {
                        "reply": "Hmm, that wasn't what I was expecting. The end result should be a dictionary that looks like this: { 'VARIABLE': 'value', 'OTHER_VARIABLE', 'other_value' }, stored in 'environment_dict'"
                    }
                }
            }
        }
    },
    {
        "name": "python_gi",
        "available_to": ["console"],
        "requires_session": true,
        "desc": "Using GObject-Introspection to interact with system libraries",
        "entry": "create_gi_binding",
        "practice": {
            "create_gi_binding": {
                "task": "On Endless OS there's a powerful framework called GObject-Introspection that allows you to interact with lots of different system components from many different languages. For instance, one of the components is called 'Gio'. 'Gio' can be imported from the namespace 'gi'. Try running 'from gi.repository import Gio'.",
                "effects": {
                    "success": {
                        "reply": "We've now imported the Gio system library. Lets see what's in there.",
                        "move_to": "instantiate_gi_class",
                        "side_effects": [
                            {
                                "type": "event",
                                "value": "showmehow-python-create-gi-binding"
                            }
                        ]
                    },
                    "failure": {
                        "reply": "Hmm, I don't see the Gio library. Are you sure you imported it correctly?"
                    }

                }
            },
            "instantiate_gi_class": {
                "task": "Something really simple we can use right now is the 'Notification' object from Gio. This can be used to send a system notification. You can create that class by just by calling Gio.Notification.new('Lets eat lunch!'). Create a new Notification object and assign it to 'notification'!",
                "effects": {
                    "success": {
                        "reply": "Notification created!",
                        "move_to": "send_gnotification",
                        "side_effects": [
                            {
                                "type": "event",
                                "value": "showmehow-python-gi-instantiate-gi-class"
                            }
                        ]
                    },
                    "failure": {
                        "reply": "Hmm, I don't see any notification with the name 'notification'"
                    }
                }
            },
            "send_gnotification": {
                "task": "Now that we've created out notification object, lets send it! This is done by using the application instance to send the notification. That can be found at the variable named 'application' which I've created for you. Have a look at https://developer.gnome.org/GNotification/ for how to send it and what to call application.send_notification with.",
                "effects": {
                    "success": {
                        "reply": "Notification sent! I'm sure you must have seen it!",
                        "completes_lesson": true,
                        "side_effects": [
                            {
                                "type": "event",
                                "value": "showmehow-python-gi-send-gnotification"
                            }
                        ]
                    },
                    "failure": {
                        "reply": "Still waiting on that notification to be sent!"
                    }
                }
            }
        }
    }
]
