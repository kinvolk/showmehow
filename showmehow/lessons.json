[
    {
        "name": "showmehow",
        "desc": "Show me how to do things in this mysterious environment...",
        "entry": "showmehow",
        "practice": {
            "showmehow": {
                "task": "'showmehow' is a command that you can type, just like any other command. Try typing it and see what happens.",
                "effects": {
                    "success": {
                        "reply": "That's right! Though now you need to tell showmehow what task you want to try. This is called an 'argument'. Try giving showmehow an argument so that it knows what to do. Want to know what argument to give it? There's only one, and it just told you what it was.",
                        "move_to": "showmehow_argument"
                    },
                    "failure": {
                        "reply": "Nope, that wasn't what I thought would happen! Try typing just 'showmehow' and hit 'enter'. No more, no less (though surrounding spaces are okay)."
                    }
                }
            },
            "showmehow_argument": {
                "task": "Lets try giving an argument to 'showmehow'. Arguments are words that come after the main command",
                "input": "console",
                "effects": {
                    "success": {
                        "reply": "Great! Now that we're done with that, maybe you can run 'showmehow' again to find out what other things you can do in this mysterious place....",
                        "completes_lesson": true

                    },
                    "failure": {
                        "reply": "Hmmm. I want to know what happens when you ask how to use 'showmehow'"
                    }
                }
            }
        }
    },
    {
        "name": "joke",
        "available_to": ["console"],
        "desc": "Tell me a joke",
        "entry": "fortune",
        "practice": {
            "fortune": {
                "task": "'fortune' is a command that can tell you a joke",
                "effects": {
                    "success": {
                        "reply": "Ha-ha. Okay, lets try something even funnier.",
                        "move_to": "fortune_cowsay"
                    },
                    "failure": {
                        "reply": "No?"
                    }
                }
            },
            "fortune_cowsay": {
                "task": "In the shell, you can pipe (|) the output of commands around into other processes. One of these processes is 'cowsay'. See what happens when you try:\n    $ fortune | cowsay",
                "effects": {
                    "success": {
                        "reply": "Moo! Try some more jokes in the shell!",
                        "completes_lesson": true
                    },
                    "failure": {
                        "reply": "Hmm, I thought a cow was going to say that"
                    }
                }
            }
        }
    },
    {
        "name": "readfile",
        "available_to": ["console"],
        "desc": "Read a file",
        "entry": "cat",
        "practice": {
            "cat": {
                "task": "'cat' can be used to read files on your computer. Meow! Lets read the file on your computer which says what operating system we're running. That file is found at /etc/os-release",
                "input": "console",
                "effects": {
                    "success":{
                        "reply": "Endless OS, as expected. Meow!",
                        "move_to": "cat_cowsay"
                    },
                    "failure": {
                        "reply": "Hmm, are you sure you're reading /etc/os-release?"
                    }
                }
            },
            "cat_cowsay": {
                "task": "And for good measure, lets get a cow to say it too.",
                "input": "console",
                "effects": {
                    "success": {
                        "reply": "Moo! You can read any file that is plain text using `cat`. Try it with files like /etc/resolv.conf",
                        "completes_lesson": true
                    },
                    "failure": {
                        "reply": "Did you get a cow to say what's in /etc/os-release? Try again"
                    }
                }
            }
        }
    },
    {
        "name": "breakit",
        "available_to": ["console"],
        "desc": "See how it is almost impossible to break anything",
        "entry": "breakit",
        "practice": {
            "breakit": {
                "task": "Its pretty difficult to break things on the command line. Try typing gibberish.",
                "effects": {
                    "success": {
                        "reply": "See? Harmless. Don't be afraid to try new things!",
                        "completes_lesson": true,
                        "side_effects": [
                            {
                                "type": "unlock",
                                "value": ["changesetting", "playsong"]
                            }
                        ]
                    },
                    "failure": {
                        "reply": "Oops, you actually ended up running something!"
                    }
                }
            }
        }
    },
    {
        "name": "changesetting",
        "available_to": ["console"],
        "desc": "Escape the terminal and tweak the OS",
        "entry": "gsettings",
        "practice": {
            "gsettings": {
                "task": "Settings for your computer can be controlled with the `gsettings` tool. Lets find out what you can do with `gsettings`.",
                "effects": {
                    "success": {
                        "reply": "The `gsettings` tool just told you about a bunch of `commands`. You can access these commands by providing the command name as an argument to `gsettings`.",
                        "move_to": "list_schemas"
                    },
                    "failure": {
                        "reply": "I thought that you were going to run `gsettings`?"
                    }
                }
            },
            "list_schemas": {
                "task": "Lets try listing all the categories, called `schemas` on your system.",
                "effects": {
                    "success": {
                        "reply": "Those are all the categories. Now lets look at settings you can tweak in your shell.",
                        "move_to": "list_keys_help"
                    },
                    "failure": {
                        "reply": "Where are my settings categories? Try running the list-schemas subcommand for gsettings"
                    }
                }
            },
            "list_keys_help": {
                "task": "Lets see how to use the `list-keys` subcommand. You can use the `help` command followed by a sub-command you want help for to see how to use it",
                "effects": {
                    "success": {
                        "reply": "Okay, so gsettings [--schemadir SCHEMADIR] list-keys SCHEMA[:PATH] is how you do it",
                        "move_to": "list_settings"
                    },
                    "failure": {
                        "reply": "I don't know how to use this list-keys option! Get me some help for it!"
                    }
                }
            },
            "list_settings": {
                "task": "Now that we know how to use list-keys, lets list all the settings available on the org.gnome.shell category, or 'schema', as it is called. Pipe it to `sort` to get them in alphabetical order",
                "effects": {
                    "success": {
                        "reply": "Interesting.... I wonder what we can play around with here...",
                        "move_to": "disable_social_bar"
                    },
                    "failure": {
                        "reply": "I want to know about the settings available for org.gnome.shell in sorted order? Can you list-schemas on org.gnome.shell using gsettings and then pipe (|) the output to `sort`?"
                    }
                }
            },
            "disable_social_bar": {
                "task": "Lets disable the social bar! The social bar's setting is enable-social-bar and it is a `boolean` setting, meaning it is either 'true' or 'false'. I checked `gsettings help set` for you and it said you can use the `set` command to change a setting with gsettings [--schemadir SCHEMADIR] set SCHEMA[:PATH] KEY VALUE",
                "effects": {
                    "success": {
                        "reply": "There we go! No facebook icon!",
                        "move_to": "enable_social_bar"
                    },
                    "failure": {
                        "reply": "Hmm, I thought you'd change the value of org.gnome.shell enable-social-bar to false, but it is still true"
                    }
                }
            },
            "enable_social_bar": {
                "task": "Now lets change it back to true",
                "effects": {
                    "success": {
                        "reply": "Okay, phew, facebook is back",
                        "move_to": "add_terminal_pinned_help"
                    },
                    "failure": {
                        "reply": "Quick! I need facebook to come back! Change enable-social-bar on org.gnome.shell back to 'true'!"
                    }
                }
            },
            "add_terminal_pinned_help": {
                "task": "Oh I know, we should add the Terminal to your pinned apps! To do that, we can add it to the list inside of the taskbar-pins setting. But first lets see what the taskbar-pins setting looks like.",
                "effects": {
                    "success": {
                        "reply": "Okay, so it is a list in square brackets, where every element is surrounded by quotation marks and separated by a comma. Just like this: ['chromium-browser.desktop', 'my-other-app.desktop']",
                        "move_to": "add_terminal_pinned"
                    },
                    "failure": {
                        "reply": "You didn't show me your pinned apps!"
                    }
                }
            },
            "add_terminal_pinned": {
                "task": "Okay, lets pin the Terminal. The Terminal's App ID is 'org.gnome.Terminal', so we should add the 'org.gnome.Terminal.desktop' entry to that list in taskbar-pins",
                "effects": {
                    "success": {
                        "reply": "Sweet, looks like I'll be sticking around!",
                        "completes_lesson": true
                    },
                    "failure": {
                        "reply": "I'm not there :( The Terminal's App ID is 'org.gnome.Terminal', so we should add the 'org.gnome.Terminal.desktop' entry to that list in taskbar-pins"
                    }
                }
            }
        }
    },
    {
        "name": "playsong",
        "available_to": ["console"],
        "desc": "Play some music",
        "entry": "playsong",
        "practice": {
            "playsong": {
                "task": "Lets play some music. GStreamer is a framework that can be used to play all sorts of media files on your computer. Rythmbox and VideoNet both use it. To play a music file, just use `gst-launch-1.0`",
                "effects": {
                    "success": {
                        "reply": "I love this song! Now you'll probably notice that we're stuck here. To get out of any command line application, you can use Control-C",
                        "completes_lesson": true
                    },
                    "failure": {
                        "reply": "We need this song to get things into the right mood. Can you play it?"
                    }
                }
            }
        }
    },
    {
        "name": "navigation",
        "available_to": ["console"],
        "requires_session": true,
        "desc": "Navigate your file system",
        "entry": "change_to_root",
        "practice": {
            "change_to_root": {
                "task": "Lets start at the top and go to the top-down view of Endless. We'll change to the 'root directory', which is the very highest folder in your system. To do that, you just need to type $ cd /",
                "effects": {
                    "success": {
                        "reply": "Time to have a look around.",
                        "move_to": "list"
                    },
                    "failure": {
                        "reply": "Are you at the very very very top? Its just four characters! $ cd /"
                    }
                }
            },
            "list": {
                "task": "On the command line, you can show all the files and folders in the directory you're currently in, just like in the file manager. To do this, use the 'ls' command. Just type after the $ ls",
                "effects": {
                    "success": {
                        "reply": "I bet you've never seen some of these files before. Lets have a look at what they are...",
                        "move_to": "list_child"
                    },
                    "failure": {
                        "reply": "Hmmm, try listing the files again, I didn't see what I expected to see"
                    }
                }
            },
            "list_child": {
                "task": "You can also see what's inside any particular folder. Try listing the contents of /home",
                "effects": {
                    "success": {
                        "reply": "See anything familiar in there? Every user on the system has their own directory.",
                        "move_to": "pwd"
                    },
                    "failure": {
                        "reply": "Hmmm, are you sure that is /home?"
                    }
                }
            },
            "pwd": {
                "task": "You might wonder what folder you're in right now? You can find out with 'pwd'",
                "effects": {
                    "success": {
                        "reply": "Wow, that's a short folder name. In fact, you're in what's called the 'root' directory, which is where all the operating system files are stored",
                        "move_to": "cd"
                    },
                    "failure": {
                        "reply": "Hmmm, are you sure that is /home?"
                    }
                }
            },
            "cd": {
                "task": "You can change the 'working directory' with the 'cd' command. Lets try changing into the 'home' directory. Just like we did before, its 'cd' followed by the name of the directory.",
                "effects": {
                    "success": {
                        "reply": "Great! The context is now changed and you're in 'home'.",
                        "move_to": "cd_and_cmd"
                    },
                    "failure": {
                        "reply": "Hmmm, are you sure that is /home?"
                    }
                }
            },
            "cd_and_cmd": {
                "task": "You can change the working directory at any time with the 'cd' command, short for 'change directory'. You can also use '&&' to chain commands together. Try $ cd /home && ls",
                "effects": {
                    "success": {
                        "reply": "Just as expected! When you change the working directory with cd you are changing the context in which a command runs, so the 'ls' command listed what was in 'home' directory.",
                        "move_to": "cd_home_dir"
                    },
                    "failure": {
                        "reply": "Hmmm, are you sure that is /home you listed?"
                    }
                }
            },
            "cd_home_dir": {
                "task": "You're probably wondering if there's a quick way to get into your home directory, since that's where you usually start. Turns out there is - the tilde (~, just above the Tab key) is a shortcut that always expands to the path of your home directory. Why don't you try changing to your home directory?",
                "effects": {
                    "success": {
                        "reply": "I'm sure you'll see some familiar stuff in here!",
                        "move_to": "list_home_dir"
                    },
                    "failure": {
                        "reply": "Hmmm, are sure you changed into your home directory??"
                    }
                }
            },
            "list_home_dir": {
                "task": "Now that you're here, why not list the contents of it. Just like before.",
                "effects": {
                    "success": {
                        "reply": "Go check if that's what you expected in the file manager!",
                        "move_to": "mkdir"
                    },
                    "failure": {
                        "reply": "Hmmm, are sure you listed your home directory??"
                    }
                }
            },
            "mkdir": {
                "task": "Now that you're getting pretty good at navigating around, what about making some new files and directories? The 'mkdir' command can be used to make a new folder. Why don't you try making a folder called ~/code? Remember that the ~ will expand to your home directory! Oh - and also, you might want to provide the '-p' switch to 'mkdir' just in case that folder is already there! So $ mkdir -p (the directory you're going to create)",
                "effects": {
                    "success": {
                        "reply": "Perhaps it might be worth checking in the file mananger to see if this folder was there!",
                        "move_to": "touch"
                    },
                    "failure": {
                        "reply": "Hmmm, I didn't see the directory. Did you make a folder named 'code' in your home directory?"
                    }
                }
            },
            "touch": {
                "task": "Now that we can make a directory, how about we try making a file, in our ~/code directory? Try making a file called 'secret.txt' in ~/code by using the 'touch' command.",
                "effects": {
                    "success": {
                        "reply": "Lets check that the file was there!",
                        "move_to": "write_to_secret"
                    },
                    "failure": {
                        "reply": "Hmmm, I didn't see the file. Did you make a file named 'secret.txt' in ~/code?"
                    }
                }
            },
            "write_to_secret": {
                "task": "Hey! Why don't we do something exciting and write down the academy password in the file we just created? Remember, it was 'kittens'. A quick shortcut to write something to a file is to use the redirect operator '>' after the command, which redirects its output to a file. One common pattern is to use the 'echo' command along with the redirect operator to overwrite a file. For instance, $ echo 'dogs' > cats.txt . Try writing 'kittens' to ~/code/secret.txt",
                "effects": {
                    "success": {
                        "reply": "Sweet, easy to find now!",
                        "completes_lesson": true
                    },
                    "failure": {
                        "reply": "Did you write 'kittens' to that file?"
                    }
                }
            }
        }
     },
     {
         "name": "text",
         "available_to": ["console"],
         "requires_session": false,
         "desc": "Process text like a ninja",
         "entry": "cat",
         "practice": {
             "cat": {
                 "task": "You can use the 'cat' command to read text from files. Why not check out the contents of sherlock.txt in this directory?",
                 "effects": {
                     "success": {
                         "reply": "Great! Now lets see what else we can do with this file.",
                         "move_to": "cat_grep"
                     },
                     "failure": {
                         "reply": "That doesn't sound anything like sherlock! Get me that file!"
                     }
                 }
             },
             "cat_grep": {
                 "task": "Sometimes (for big files) you might only want to see lines which have certain words in them. This is pretty common if you're seaching code for things. To filter out all lines which don't contain a particular word, you can use the 'grep' command. Try piping (|) the output of 'cat' on 'sherlock.txt' to grep and search for anything that talks about the year 1900 onwards (that means any word starting with 19).",
                 "effects": {
                     "success": {
                         "reply": "See how that makes the needles a lot easier to find in the haystack?",
                         "move_to": "grep_file"
                     },
                     "failure": {
                         "reply": "I just need the lines talking about 1900 onwards. Remember that you can pipe things by using the | operator, for instance, cat 'kittens.txt' | grep cats"
                     }
                 }
             },
             "grep_file": {
                 "task": "I lied. You don't actually have to pipe the output of 'cat' to 'grep' to search a file. You can just use 'grep' on the file directly. But I did show you the usefulness of 'streams' in the context of the shell. Why don't you try just using 'grep' directly on 'sherlock.txt' with the same query (everything to do with the 1900s).",
                 "effects": {
                     "success": {
                         "reply": "Same result!",
                         "move_to": "grep_extended_regex"
                     },
                     "failure": {
                         "reply": "You should get the same result as piping it to cat. Just try `grep <expression> sherlock.txt`."
                     }
                 }
             },
             "grep_extended_regex": {
                 "task": "But what if I told you I wanted to know about 1800 and 1900, or really anything to do with a year in that piece of text? You can use extended grep with a regular expression. There's way too much for me to tell you about them right now, but you can go to http://docs.activestate.com/komodo/4.4/regex-intro.html for some basic ones. Why don't you head over there, come back and type in a command using grep -E <regular expression> to find all lines with a 4-digit year?",
                 "effects": {
                     "success": {
                         "reply": "There we go, you searched for two things at once! Bet you couldn't do that in a word processor!",
                         "move_to": "grep_all"
                     },
                     "failure": {
                         "reply": "Nope, I just need the lines with years in them, but that includes years in the 1800s as well! Have a look http://docs.activestate.com/komodo/4.4/regex-intro.html again and see if you can come up with a regular expression to give to `grep -E`."
                     }
                 }
             },
             "grep_all": {
                 "task": "So now you can search one file for many things using regular expressions, but what about searching lots of files for one or more things? Well, `grep` allows you to search directories, which can be incredibly useful if you're trying to find files with certain words in them. Academy members do this with code all the time. Lets try it on the code/ directory. I'm looking for code that uses GSettings. You can a directory by providing the `-R` option to grep. For instance, grep -R <expression> <directory>. Can you find me all the lines that use GSettings?",
                 "effects": {
                     "success": {
                         "reply": "Ah! Found them all! Thanks, that will be quite useful later on.",
                         "move_to": "grep_all_regex"
                     },
                     "failure": {
                         "reply": "Not quite what I was expecting. Sure you searched just for GSettings?"
                     }
                 }
             },
             "grep_all_regex": {
                 "task": "You can of course, use a regex to search multiple files as well. All those 'GSettings' words that you found in the code were actually what are called 'types' in C code. In fact, anything type that starts with a 'G' is usually from a set of frameworks which are called 'GNOME'. These frameworks power everything you see in Endless OS and is what most of our applications are built with. Try doing a recursive search on code/ for everything beginning with the letter 'G' and see what you find!",
                 "effects": {
                     "success": {
                         "reply": "There's so many different things in use here! And we're going to learn about how they all fit together.",
                         "move_to": "cat_atlas"
                     },
                     "failure": {
                         "reply": "Oh c'mon, there's got to be way more than that!"
                     }
                 }
             },
             "cat_atlas": {
                 "task": "And now for something completely different. You can do some nifty processing with tabular data using the 'awk' utility. I've stored a file called 'atlas.txt' in the current directory. Lets have a look at it with 'cat'.",
                 "effects": {
                     "success": {
                         "reply": "There's some interesting information on countries here. But lets see what else we can do with it.",
                         "move_to": "awk_atlas"
                     }
                 }
             },
             "awk_atlas": {
                 "task": "Lets say I only want to know about the countries in that file and nothing else. 'awk' allows you to select columns from tabular data. You'll need to pass an awk-expression to it to let it know what you want to show. For instance, `cat atlas.txt | awk '{print $1}'`",
                 "effects": {
                     "success": {
                         "reply": "Great, just the countries!",
                         "move_to": "awk_atlas_countries_sorted"
                     },
                     "failure": {
                         "reply": "Hmm, I just wanted to see countries."
                     }
                 }
             },
             "awk_atlas_countries_sorted": {
                 "task": "Lets say I wanted to see the same thing, but in sorted order? You can pipe to the 'sort' command sort the output.",
                 "effects": {
                     "success": {
                         "reply": "And that's in sorted order as expected!",
                         "move_to": "awk_atlas_continents"
                     },
                     "failure": {
                         "reply": "Hmm, I was expecting a sorted order. Can you do that for me?"
                     }
                 }
             },
             "awk_atlas_continents": {
                 "task": "Lets just show continents. Do you remember what column they were? Try showing them with 'awk'.",
                 "effects": {
                     "success": {
                         "reply": "Great, just the continents. But there's duplicates!",
                         "move_to": "awk_atlas_continents_uniq"
                     },
                     "failure": {
                         "reply": "Hmm, I was just expecting continents. Did you print the right column?"
                     }
                 }
             },
             "awk_atlas_continents_uniq": {
                 "task": "There is a way to remove those duplicates though! Piping to the `sort` and then to the  `uniq` utility will do that. Why don't you give that a try?",
                 "effects": {
                     "success": {
                         "reply": "Great! So there are 5 continents in that file. Maybe there will be some more to come soon.",
                         "completes_lesson": true
                     },
                     "failure": {
                         "reply": "Almost there! I just need a view of all the unique continents in that file."
                     }
                 }
             }
         }
     },
     {
         "name": "ps",
         "available_to": ["console"],
         "requires_session": false,
         "desc": "Get a birds eye view of what's running on your system",
         "entry": "ps",
         "practice": {
             "ps": {
                 "task": "Ever wanted to know what processes are currently running on your computer? You can show a detailed view of everything using the 'ps' command",
                 "effects": {
                     "success": {
                         "reply": "There's some processes, but only a few. I wonder where all the rest are?",
                         "move_to": "ps_aux"
                     },
                     "failure": {
                         "reply": "I'm looking for something that says what processes are running on your system. Tried 'ps'?"
                     }
                 }
             },
             "ps_aux": {
                 "task": "'ps' told you about some of the processes running on your system, but only a few of them. The manual for it says that 'By default, ps selects all processes with the same effective user ID (euid=EUID) as the current user and associated with the same terminal as the invoker.  It displays the process ID (pid=PID), the terminal associated with the process (tname=TTY), the cumulated CPU time in [DD-]hh:mm:ss format (time=TIME), and the executable name (ucmd=CMD).'. That's a lot of mumbo-jumbo! I think what the manual is trying to say there is that the processes running on your system can have children and parents. Different processes can be attached to different output terminals. Some run in the background and some run on the current terminal. 'ps' just displays what's on the current terminal and running as the current user. If you want to see everything, try the 'aux' switch.",
                 "effects": {
                     "success": {
                         "reply": "Okay, lots of processes now, including the ones running by other users!",
                         "move_to": "ps_aux_grep"
                     },
                     "failure": {
                         "reply": "Hmm. Is that every process on the system?"
                     }
                 }
             },
             "ps_aux_grep": {
                 "task": "Okay, now that we have every process running on the system, I wonder if we can find the process that is running me? My name is showmehow-service. Why don't you try connecting ps aux with 'grep' in order to find out some information about my process?",
                 "effects": {
                     "success": {
                         "reply": "Yup, that's me.",
                         "move_to": "ps_aux_grep_awk"
                     },
                     "failure": {
                         "reply": "I think I know what I look like and I didn't see myself in there. Remember that you can pipe the output of any command to 'grep' to find lines which match a pattern."
                     }
                 }
             },
             "ps_aux_grep_awk": {
                 "task": "Now that you've got the line just showing me, see if you can just get my process id. Remember that the output of 'ps' is tabular, so you can use it with 'awk'. Remember that the process id is always in the second column of ps aux.",
                 "effects": {
                     "success": {
                         "reply": "Horray, a process id!",
                         "move_to": "view_proc_pid"
                     },
                     "failure": {
                         "reply": "Are you sure that's my process id?"
                     }
                 }
             },
             "view_proc_pid": {
                 "task": "With my process id, you can view all the different information that Endless OS stores about me. All that information is actually stored in 'fake' files and folders on your system located at /proc/PID, where PID is the process ID of the process. Why don't you try running 'ls' on that directory and seeing what's there.",
                 "effects": {
                     "success": {
                         "reply": "Wow lots of information and I bet you don't even know where to start",
                         "move_to": "view_proc_cmdline"
                     },
                     "failure": {
                         "reply": "There should be more files and folders than that..."
                     }
                 }
             },
             "view_proc_cmdline": {
                 "task": "Perhaps the first place to start is to view how some of these processes were actually launched. You can do that by viewing the 'cmdline' file in /proc/PID. Why not try viewing that file with 'cat'?",
                 "effects": {
                     "success": {
                         "reply": "Ah-ha, so this process wasn't actually launched directly, but it was launched with something else called 'gjs'. Maybe we should find out what that is.",
                         "completes_lesson": true
                     },
                     "failure": {
                         "reply": "I don't think that was my command line. I was launched with something ... now what was it."
                     }
                 }
             }
         }
     },
     {
         "name": "ps",
         "available_to": ["console"],
         "requires_session": false,
         "desc": "Get a birds eye view of what's running on your system",
         "entry": "ps",
         "practice": {
             "ps": {
                 "task": "Ever wanted to know what processes are currently running on your computer? You can show a detailed view of everything using the 'ps' command",
                 "effects": {
                     "success": {
                         "reply": "There's some processes, but only a few. I wonder where all the rest are?",
                         "move_to": "ps_aux"
                     },
                     "failure": {
                         "reply": "I'm looking for something that says what processes are running on your system. Tried 'ps'?"
                     }
                 }
             },
             "ps_aux": {
                 "task": "'ps' told you about some of the processes running on your system, but only a few of them. The manual for it says that 'By default, ps selects all processes with the same effective user ID (euid=EUID) as the current user and associated with the same terminal as the invoker.  It displays the process ID (pid=PID), the terminal associated with the process (tname=TTY), the cumulated CPU time in [DD-]hh:mm:ss format (time=TIME), and the executable name (ucmd=CMD).'. That's a lot of mumbo-jumbo! I think what the manual is trying to say there is that the processes running on your system can have children and parents. Different processes can be attached to different output terminals. Some run in the background and some run on the current terminal. 'ps' just displays what's on the current terminal and running as the current user. If you want to see everything, try the 'aux' switch.",
                 "effects": {
                     "success": {
                         "reply": "Okay, lots of processes now, including the ones running by other users!",
                         "move_to": "ps_aux_grep"
                     },
                     "failure": {
                         "reply": "Hmm. Is that every process on the system?"
                     }
                 }
             },
             "ps_aux_grep": {
                 "task": "Okay, now that we have every process running on the system, I wonder if we can find the process that is running me? My name is showmehow-service. Why don't you try connecting ps aux with 'grep' in order to find out some information about my process?",
                 "effects": {
                     "success": {
                         "reply": "Yup, that's me.",
                         "move_to": "ps_aux_grep_awk"
                     },
                     "failure": {
                         "reply": "I think I know what I look like and I didn't see myself in there. Remember that you can pipe the output of any command to 'grep' to find lines which match a pattern."
                     }
                 }
             },
             "ps_aux_grep_awk": {
                 "task": "Now that you've got the line just showing me, see if you can just get my process id. Remember that the output of 'ps' is tabular, so you can use it with 'awk'. Remember that the process id is always in the second column of ps aux.",
                 "effects": {
                     "success": {
                         "reply": "Horray, a process id!",
                         "move_to": "view_proc_pid"
                     },
                     "failure": {
                         "reply": "Are you sure that's my process id?"
                     }
                 }
             },
             "view_proc_pid": {
                 "task": "With my process id, you can view all the different information that Endless OS stores about me. All that information is actually stored in 'fake' files and folders on your system located at /proc/PID, where PID is the process ID of the process. Why don't you try running 'ls' on that directory and seeing what's there.",
                 "effects": {
                     "success": {
                         "reply": "Wow lots of information and I bet you don't even know where to start",
                         "move_to": "view_proc_cmdline"
                     },
                     "failure": {
                         "reply": "There should be more files and folders than that..."
                     }
                 }
             },
             "view_proc_cmdline": {
                 "task": "Perhaps the first place to start is to view how some of these processes were actually launched. You can do that by viewing the 'cmdline' file in /proc/PID. Why not try viewing that file with 'cat'?",
                 "effects": {
                     "success": {
                         "reply": "Ah-ha, so this process wasn't actually launched directly, but it was launched with something else called 'gjs'. Maybe we should find out what that is.",
                         "completes_lesson": true
                     },
                     "failure": {
                         "reply": "I don't think that was my command line. I was launched with something ... now what was it."
                     }
                 }
             }
         }
     },
     {
         "name": "webrequest",
         "desc": "Download stuff using the terminal",
         "available_to": ["console"],
         "entry": "wget_image",
         "practice": {
             "wget_image": {
                 "task": "If you just want to quickly download something and you know the URL, you can use wget to grab it and save the file to the current directory. Why don't you try using wget to download this image from the Endless website: https://endlessm.com/wp-content/uploads/2016/05/ourcomputers_hero-1.jpg",
                 "effects": {
                     "success": {
                         "reply": "Cool. Try checking out the image in your home directory. It should be there now.",
                         "move_to": "api_pokemon"
                     }
                 }
             },
             "api_pokemon": {
                 "task": "Did you know that the internet you see is only half of what is out there? Lots of things that you use on the internet communicate through a structured format called JSON or another one called XML. Like any other thing on the internet, you can ask some of these services questions and get back a semi-structured answer with `curl`. There's even a service out there that can tell you anything about Pokemon, called PokeAPI. Why not try getting some information about Bulbasaur from http://pokeapi.co/api/v2/pokemon/1/.",
                 "effects": {
                     "success": {
                         "reply": "Woooaaaahhh that's a lot of data! We're going to have to do something about that.",
                         "move_to": "api_pokemon_types"
                     }
                 }
             },
             "api_pokemon_types": {
                 "task": "Lets get something a little more managable, like what type Bulbasaur is. The output PokeAPI gave us was JSON formatted, so we can use the 'ramda' tool to do some processing on it. 'ramda' has some great documentation at https://github.com/ramda/ramda/wiki/What-Function-Should-I-Use%3F. Before we process the object with 'ramda', we'll need to make sure we only get the body of the request using 'curl -LSs'. For now, we're working on what is called an 'Object' and we want to select a specific key, that being the 'types' key. To do that, we can use the 'prop' command. Try it: $ curl -LSs http://pokeapi.co/api/v2/pokemon/1/ | ramda 'prop \\types'",
                 "effects": {
                     "success": {
                         "reply": "Poison and Grass as we expected.",
                         "move_to": "api_pokemon_in_type"
                     },
                     "failure": {
                         "reply": "Hmm, not the types I expected."
                     }
                 }
             },
             "api_pokemon_in_type": {
                 "task": "Lets find out more about the poison type. I'd be really useful if we knew about every Pokemon that was of the poison type. To do this, we'll pick the 'poison' key out of the link provided for 'poison'. Try it and see what you get.",
                 "effects": {
                     "success": {
                         "reply": "Yep, that contains the pokemon that I thought. Next time you're on the hunt for poison Pokemon you know which ones you might have missed.",
                         "completes_lesson": true
                     }
                 }
             }
         }
     },
     {
        "name": "python_lists",
        "available_to": ["console"],
        "requires_session": true,
        "desc": "Working with lists in python",
        "entry": "convert_list",
        "practice": {
            "convert_list": {
                "task": "Python provides some really nifty utilities to convert lists of one thing into lists of another. This is really useful for when you're trying to convert data from one format to another. These utilities are called 'list comprehensions'. You can see more about the syntax of these on https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions. To try it out, I've created a list called 'numbers' and I want you to give me back a list of every number multiplied by 5, assigned to the value 'fives'.",
                "effects": {
                    "success": {
                        "reply": "Success! You've now used your first list comprehension!",
                        "move_to": "filter_list"
                    },
                    "failure": {
                        "reply": "Nope, I don't see a list around with multiples of five. Did you assign the result to 'fives'?"
                    }
                }
            },
            "filter_list": {
                "task": "With list comprehensions you can also filter out things from lists in a single line. Lets try it with the same thing. I want you to filter out every number that is odd. Have a look at the documentation link provided earlier for how to do it. You can use the modulo (%) operator to get the remainder of a division. Remember, that a number divides perfectly if there is no remainder! Assign the result to 'filtered'.",
                "effects": {
                    "success": {
                        "reply": "Now this list only has even numbers!",
                        "move_to": "dict_comprehension"
                    },
                    "failure": {
                        "reply": "Hmm, I'm expecting a list containing only even numbers at 'filtered'"
                    }
                }
            },
            "dict_comprehension": {
                "task": "Comprehensions aren't just limited to lists. You can also build dictionary types using comprehensions too. Dictionary types map keys to values and provide a really convenient way of getting an associated value if you know what a unique identifier for it will be. Lets try combining everything you've learnt. I'm going to put a string containing your system's environment variables in the variable 'environment'. This variable looks like 'VARIABLE=value OTHER_VARIABLE=value'. Split that into a list of strings and then use each item of the list to build up the keys and values for the dictionary. You will probably want to split each string on the '=' sign. Store the result in 'environment_dict'.",
                "effects": {
                    "success": {
                        "reply": "Congratulations! You're mastering data structures in Python now!",
                        "completes_lesson": true
                    },
                    "failure": {
                        "reply": "Hmm, that wasn't what I was expecting. The end result should be a dictionary that looks like this: { 'VARIABLE': 'value', 'OTHER_VARIABLE', 'other_value' }, stored in 'environment_dict'"
                    }
                }
            }
        }
    },
    {
        "name": "python_gi",
        "available_to": ["console"],
        "requires_session": true,
        "desc": "Using GObject-Introspection to interact with system libraries",
        "entry": "create_gi_binding",
        "practice": {
            "create_gi_binding": {
                "name": "On Endless OS there's a powerful framework called GObject-Introspection that allows you to interact with lots of different system components from many different languages. For instance, one of the components is called 'Gio'. 'Gio' can be imported from the namespace 'gi'. Try running 'from gi import Gio'.",
                "effects": {
                    "success": {
                        "reply": "We've now imported the Gio system library. Lets see what's in there.",
                        "move_to": "instantiate_gi_class"
                    },
                    "failure": {
                        "reply": "Hmm, I don't see the Gio library. Are you sure you imported it correctly?"
                    }

                }
            },
            "instantiate_gi_class": {
                "name": "Something really simple we can use right now is the 'Notification' object from Gio. This can be used to send a system notification. You can create that class by just by calling Gio.Notification.new('Lets eat lunch!'). Create a new Notification object and assign it to 'notification'!",
                "effects": {
                    "success": {
                        "reply": "Notification created!",
                        "move_to": "send_gnotification"
                    },
                    "failure": {
                        "reply": "Hmm, I don't see any notification with the name 'notification'"
                    }
                }
            },
            "send_gnotification": {
                "name": "Now that we've created out notification object, lets send it! This is done by using the application instance to send the notification. That can be found at the variable named 'application' which I've created for you. Have a look at https://developer.gnome.org/GNotification/ for how to send it and what to call application.send_notification with.",
                "effects": {
                    "success": {
                        "reply": "Notification sent! I'm sure you must have seen it!",
                        "completes_lesson": true
                    },
                    "failure": {
                        "reply": "Still waiting on that notification to be sent!"
                    }
                }
            }
        }
    }
]
